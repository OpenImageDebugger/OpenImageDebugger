/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-2019 OpenImageDebugger
 * (https://github.com/OpenImageDebugger/OpenImageDebugger)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#ifndef OID_WINDOW_H_
#define OID_WINDOW_H_

// Ignore warnings from Python library
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-register"
#include <Python.h>
#pragma GCC diagnostic pop

#ifndef OID_API
#  if __GNUC__ >= 4
#    define OID_API __attribute__((visibility("default")))
#  else
#    define OID_API
#  endif
#endif

#ifdef __cplusplus
extern "C" {
#endif


typedef void* AppHandler;


/**
 * Initialize OID application
 *
 * @param plot_callback  Callback function to be called when the user requests
 *     a symbol name from the OpenImageDebugger window
 * @param optional_parameters  Dictionary with the following optional members:
 *   - oid_path  Path where the plugin is located
 * @return  Application context
 */
OID_API
AppHandler oid_initialize(int (*plot_callback)(const char*),
                          PyObject* optional_parameters);

/**
 * Cleanup and close OID user interface
 *
 * @param handler  Application context generated by oid_initialize()
 */
OID_API
void oid_cleanup(AppHandler handler);

/**
 * Execute GUI loop
 *
 * This methods blocks the caller until the OID window is closed. If
 * non-blocking behavior is desired, it must be called from a dedicated thread.
 * Notice that it must also be called in the same thread as oid_initialize().
 *
 * @param handler  Application context
 */
OID_API
void oid_exec(AppHandler handler);

/**
 * Check if the given window is open
 *
 * @param handler  Window handler, generated by oid_initialize()
 * @return  Returns 1 if the window has been fully initialized, 0 otherwise.
 */
OID_API
int oid_is_window_ready(AppHandler handler);


/**
 * Get a list of the names of all buffers being visualized
 *
 * Returns a python list object with the names of all buffers present in the
 * visualization list.
 *
 * @param handler  Window handler, generated by oid_initialize()
 * @return  Python list object containing python str objects with the names of
 *     all buffers being visualized.
 */
OID_API
PyObject* oid_get_observed_buffers(AppHandler handler);

/**
 * Set list of symbols available in the current context
 *
 * Sets a list of names of variables available for plotting in the current
 * context. This list will serve as base for the autocomplete mechanism in the
 * symbol searcher input.
 *
 * @param handler  Window handler, generated by oid_initialize()
 * @param available_set  Python list of python str objects containing the names
 *     of all available symbols in the current context.
 */
OID_API
void oid_set_available_symbols(AppHandler handler,
                               PyObject* available_vars);


/**
 * Process pending events related to communication with UI
 *
 * Must be called in order for requests from the UI to reach the debugger
 * bridge.
 *
 * @param handler  Window handler, generated by oid_initialize()
 */
OID_API
void oid_run_event_loop(AppHandler handler);


/**
 * Add a buffer to the plot list
 *
 * @param handler  Handler of the window where the buffer should be plotted
 * @param buffer_metadata  Python dictionary with the following elements:
 *     - [pointer     ] PyMemoryView object wrapping the target buffer
 *     - [display_name] Variable name as it shall be displayed
 *     - [width       ] Buffer width, in pixels
 *     - [height      ] Buffer height, in pixels
 *     - [channels    ] Number of channels (1 to 4)
 *     - [type        ] Buffer type (see symbols.py for details)
 *     - [row_stride  ] Row stride, in pixels
 *     - [pixel_layout] String defining pixel channel layout (e.g. 'rgba')
 * */
OID_API
void oid_plot_buffer(AppHandler handler, PyObject* bufffer_metadata);

#ifdef __cplusplus
}
#endif

#endif
